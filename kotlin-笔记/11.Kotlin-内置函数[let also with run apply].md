#安全调用操作符
安全调用允许在可空类型上调用函数，但是如果还想做【额外的事情】比如创建新值，或者判断不为null就调用其他函数。怎么办？
可以在任何类型上调用let函数
[1.let函数] 
#定义：一个作用域函数
#作用：定义一个变量在一个特定的作用域范围内避免写一些判断null的操作
#场景：明确一个变量所处特定的作用域范围内可使用，针对一个可null的对象统一做判null处理。
#使用方法：
// 作用1：使用it替代object对象去访问其公有的属性 & 方法
object.let{
   it.todo()
}
// 作用2：判断object为null的操作
object?.let{//表示object不为null的条件下，才会去执行let函数体
   it.todo()
}
[注：返回值 = 最后一行 / return的表达式]
>使用示例
// 使用Java
 if( mVar != null ){
     mVar.function1();
     mVar.function2();
     mVar.function3();
 }
 // 使用kotlin（无使用let函数）
 mVar?.function1()
 mVar?.function2()
 mVar?.function3()
 // 使用kotlin（使用let函数）
 // 方便了统一判空的处理 & 确定了mVar变量的作用域
 mVar?.let {
        it.function1()
        it.function2()
        it.function3()
 }

[2.also函数]
#2.1 作用 & 应用场景
类似let函数，但区别在于返回值：

let函数：返回值 = 最后一行 / return的表达式
also函数：返回值 = 传入的对象的本身

# 使用示例
>2.2
// let函数
var result = mVar.let {
               it.function1()
               it.function2()
               it.function3()
               999
}
// 最终结果 = 返回999给变量result
// also函数
var result = mVar.also {
               it.function1()
               it.function2()
               it.function3()
               999
}
// 最终结果 = 返回一个mVar对象给变量result

[3.with函数]
#3.1 作用
调用同一个对象的多个方法 / 属性时，可以省去对象名重复，直接调用方法名 / 属性即可

#3.2 应用场景
需要调用同一个对象的多个方法 / 属性
#3.3 使用方法
 with(object){
   // ... 
 }
// 返回值 = 函数块的最后一行 / return表达式
>3.4 使用示例
// 此处要调用people的name 和 age属性
// kotlin
val people = People("carson", 25)
with(people) {
println("my name is $name, I am $age years old")
}
// Java
User peole = new People("carson", 25);
String var1 = "my name is " + peole.name + ", I am " + peole.age + " years old";
System.out.println(var1);

[4.run函数]
#4.1 作用 & 应用场景
结合了let、with两个函数的作用，即：

调用同一个对象的多个方法 / 属性时，可以省去对象名重复，直接调用方法名 / 属性即可
定义一个变量在特定作用域内
统一做判空处理
#4.2 使用方法
object.run{
// ... 
}
// 返回值 = 函数块的最后一行 / return表达式
>4.3 使用示例
 // 此处要调用people的name 和 age属性，且要判空
 // kotlin
 val people = People("carson", 25)
 people?.run{
     println("my name is $name, I am $age years old")
 }
 // Java
 User peole = new People("carson", 25);
 String var1 = "my name is " + peole.name + ", I am " + peole.age + " years old";
 System.out.println(var1);

[5. apply函数]
调用一个函数配置接收者时，变量名省掉了，这是因为在lambda表达式中，apply能让每个配置函数都作用于接收者，这种行为叫做相关作用域
lambda表达式里的所有函数调用都是针对接受者的，他们是针对接收者的隐式调用。
#5.1 作用 & 应用场景
与run函数类似，但区别在于返回值：

run函数返回最后一行的值 / 表达式
apply函数返回传入的对象的本身
#5.2 应用场景`
对象实例初始化时需要对对象中的属性进行赋值 & 返回该对象
>5.3 使用示例
// run函数
val people = People("carson", 25)
val result = people?.run{
    println("my name is $name, I am $age years old")
    999
}
// 最终结果 = 返回999给变量result
// apply
val people = People("carson", 25)
val result = people?.apply{
    println("my name is $name, I am $age years old")
    999
}
// 最终结果 = 返回一个people对象给变量result


##        作用                    应用场景               备注
let  统一判null处理   正对可null的对象统一判null处理     返回 = 最后一行/return的表达式
also 同上            同上                           返回 = 传入对象本身
with 省去对象名重复    需要调用同一个对象的多个方法，属性。 返回 = 最后一行/return的表达式
run  let+with       统一判null+调用对象属性方法        返回 = 最后一行/return的表达式
apply also+with      同上                           返回 = 传入对象本身

[6.takeIf函数]
#6.1 作用 
需要判断lambda提供的条件表达式，给出ture和false
true->返回接收者对象
false->返回null
#6.2 应用场景
需要判断某个条件是否满足，在决定是否可以赋值变量或者执行某个任务。

[7.takeUnless函数]
takeIf辅助函数takeUnless，只有判断你给定的条件结果是false时。takeUnless才会返回原始接收对象。






##