[扩展函数]
# 1 定义扩展函数 -->Hello21
 扩展可以在[不直接修改类定义的情况下增加类功能]，扩展可以用于自定义类，也可以用于比如list，string以及kotlin标准库里的其他类。
 和继承相似，扩展也能共享类行为，在你[无法接触某个类定义，或者某个类没有使用open修饰符，导致你无法继承它时]，就可以选择扩展。
 
 java中protype来做这个事情。
 

# 2 超类上定义扩展函数 -->Hello21
>fun Any.easyPrint() = println(this)

# 3 泛型扩展函数 -->Hello21
如果想在addExt扩展函数之前和之后分别打印字符串怎么办？
fun <T> T.easyPrint1(): T {
    println("start")
    return this
} 
"abc".easyPrint1().addExt(4).easyPrint1()



#4 标准函数与泛型扩展函数
泛型扩展函数在kotlin标准库中随处可见，例如let函数，let函数被定义成了泛型扩展函数，所以能支持任何类型，它接受一个lambda表达式，
lambda接受者T作为值参，返回的R-lambda表达式返回的任何新类型。
>public inline fun <T, R> T.let(block: (T) -> R): R {
    contract {
        callsInPlace(block, InvocationKind.EXACTLY_ONCE)
    }
    return block(this)
}

#5 扩展属性 -->Hello21
除了给类添加功能扩展函数外，你还可以给类定义扩展属性，给String类添加一个扩展，这个扩展属性可以统计字符串里有多少个元音字母。
>val String.numVowels
     get() = count { "aeiou".contains(it) }

#6 可空类扩展
你也可以定义扩展函数用于可空类型，在可空类型上定义扩展函数，你就可以直接在扩展函数体内解决可能出现的空值问题。
>fun String?.printWithDefault(default: String) = print(this ?: default)
>val nullString: String? = "efd"
 nullString.printWithDefault("adc")
#7 infix关键字
用于单个参数的扩展和类函数，可以让你更简结的语法调用函数，[接收者和函数之间的点操作以及参数的一对括号都可以不要]。
>infix fun String?.printWithDefault(default: String) = print(this ?: default)
>val nullString: String? = "efd"
 [nullString printWithDefault "adc"]

#8 扩展文件
扩展函数可以单独定义在文件中，然后import
>A.kt
package com.xxx.xxx.xxx
fun<T> Iterable<T>.randomTake():T = this.shuffled().first()
>B.kt
import com.xxx.xxx.xxx
fun main(){
 val list = listOf("a","b","c")
 list.randomTake()
}

#9 重命名扩展 xxx as xxx

#10 apply函数详情

#11 DSL
使用这样的编码范式，就可以写成业界知名的”领域特定语言"[DSL] 
一种api编程范式，暴露接收者的函数和特性，以便于使用你定义的的lambda表达式来读取和配置他们。
//不带泛型的写法
public inline fun File.apply(block: File.() -> Unit): File {
    block()
    return this
}
