[函数.高阶]
#定义参数是函数的函数
>函数的参数是另外一个函数
fun main() {
    //获取促销文案
    val getDiscountWords: (String, Int) -> String = { goodsName, hour ->
            val currentYear = 2027
            "${currentYear}年，双11 $goodsName 促销倒计时:$hour 小时}"
    }
    val getDiscountWords = { goodsName: String, hour: Int ->
        val currentYear = 2027
        "${currentYear}年，双11 $goodsName 促销倒计时:$hour 小时}"
    }
    //展示
    showOnBoard("卫生纸", getDiscountWords)
}
//具名参数
fun showOnBoard(goodsName: String, showDiscount: (String, Int) -> String) {
    val hour: Int = (1..24).shuffled().last()
    println(showDiscount(goodsName, hour))
}
#简略写法
>如果一个函数的*lambda参数排在最后，或者是唯一的参数*，那么括号lambda值参的一对圆括号可以省略
>"Mississippi".count({it=='s'})
> [圆括号省略]
>"Mississippi".count{it=='s'}

#函数内联
>lambda可以让你代码更加灵活，但是在jvm上，你定义的lambda会以对象实例的形式存在，jvm会为所有同lambda打交道
    的变量分配内存，这就产生了内存开销。更糟的是，lambda的内存开销会带来严重的性能问题。幸运的是，kotlin有一种
    优化机制叫做内联。哪里需要lambda，编译器会将函数体复制粘贴到哪里。jvm不需要使用lambda实例对象，避免内存分配。
>使用lambda的*递归函数无法内联*。因为会导致复制粘贴无限循环，编译发出警告

#函数引用  [::]
 showOnBoard("牙膏", ::getDiscountWords)
 
#函数类型作为返回类型
>函数类型也是有效的返回类型，也就是说可以定义一个能返回函数的函数。
 fun main() {
     val text: (String) -> String = showText()
     println(text("Jack"))
 }
 private fun showText(): (String) -> String {
     return { name: String -> "hello $name" }
 }

#闭包  作用域的问题
在kotlin中，匿名函数能*修改并引用定义*在自己作用域*之外的变量*。[kotlin中的lambda就是闭包]。
能接收函数或者返回函数的函数叫做高级函数。

















########end############