[定义类]

对比java的class来看 封装 继承 多态

# 1 field
针对你定义的每一个属性,kotlin都会产生一个field,用来存储属性数据.暴露getter和setter方法.
在需要控制如何读写属性数据时,你也可以自定义他们.

# 2 初始化
主构造函数 class player(_name:String){}
>临时变量 通常以下划线开头的名字命名  class player(_name:String){}
>主构造函数里面定义属性  class player(var name:String){} 可以减少重复代码.

次构造函数 constructor(name:String,age:Int):this(name)
>定义初始化代码逻辑 
constructor(name:String,age:Int):this(name){
    this.name = name.toUpperCase()
}

默认参数 class player(_name:String,age:Int = 20){}

# 3 初始化块
初始化块可以设置变量或值,以及执行有效性检查,如检查传给某构造函数的值是否有效,[初始化快代码会在构造类实例时执行].
java的静态代码快,会在类加载就初始化,
kotlin的初始化快,是在构造类实例时执行.
>init{
}

# 4 初始化顺序
>主构造函数里声明的属性
>类级别的属性赋值
>init初始化快里面的属性赋值和函数调用
>次构造函数里的属性赋值和函数调用

# 5 延迟初始化 lateinit 告诉编译器,我后续自己做初始化操作
lateinit var name:String


# 6 惰性初始化 by lazy 暂时不初始化,直到首次使用它,才去初始化
val config by lazy{config="xxx"}

# 7 陷阱1
 // blood 要声明在init之前才能使用  
    init {
        val bloodBonus: Int = blood.times(4)
    }
    val blood = 100
    
# 8  陷阱2
class Hello16_3() {
    val name: String
    init {
        println(name)
        name = "jack"
    }
}

# 9   陷阱3
class Hello16_4(_name: String) {
    val playerName: String = initPlayerName()
    val name: String = _name
    private fun initPlayerName() = name
}